diff --git a/drivers/pci/controller/pcie-rockchip-host.c b/drivers/pci/controller/pcie-rockchip-host.c
index 5c74bf5e2..7dbbbb65d 100644
--- a/drivers/pci/controller/pcie-rockchip-host.c
+++ b/drivers/pci/controller/pcie-rockchip-host.c
@@ -298,9 +298,9 @@ static void rockchip_pcie_set_power_limit(struct rockchip_pcie *rockchip)
 static int rockchip_pcie_host_init_port(struct rockchip_pcie *rockchip)
 {
        struct device *dev = rockchip->dev;
-       int err, i = MAX_LANE_NUM;
+       int err, i = MAX_LANE_NUM, attempt_counter = 0;;
        u32 status;
-
+err_retry_init:
        gpiod_set_value_cansleep(rockchip->ep_gpio, 0);

        err = rockchip_pcie_init_port(rockchip);
@@ -336,7 +336,7 @@ static int rockchip_pcie_host_init_port(struct rockchip_pcie *rockchip)
                                 status, PCIE_LINK_UP(status), 20,
                                 500 * USEC_PER_MSEC);
        if (err) {
-               dev_err(dev, "PCIe link training gen1 timeout!\n");
+               dev_err(dev, "PCIe link training gen1 timeout with x%d!\n", status);
                goto err_power_off_phy;
        }

@@ -353,7 +353,7 @@ static int rockchip_pcie_host_init_port(struct rockchip_pcie *rockchip)
                                         status, PCIE_LINK_IS_GEN2(status), 20,
                                         500 * USEC_PER_MSEC);
                if (err)
-                       dev_dbg(dev, "PCIe link training gen2 timeout, fall back to gen1!\n");
+                       dev_dbg(dev, "PCIe link training gen2 timeout with x%d, fall back to gen1!\n", status);
        }

        /* Check the final link width from negotiated lane counter from MGMT */
@@ -401,6 +401,8 @@ static int rockchip_pcie_host_init_port(struct rockchip_pcie *rockchip)
        i = MAX_LANE_NUM;
        while (i--)
                phy_exit(rockchip->phys[i]);
+       if(attempt_counter++ < 5)
+               goto err_retry_init;
        return err;
 }
